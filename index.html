<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <title>tour-1771695558573 - Ø¬ÙˆÙ„Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div class="info">ğŸ—ï¸ tour-1771695558573</div>
    <div id="container"></div>

    <script>
        fetch('paths.json')
            .then(res => res.json())
            .then(pathsData => {
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                camera.position.set(0, 0, 0.1);
                
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('container').appendChild(renderer.domElement);
                
                const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
                scene.add(ambientLight);
                
                new THREE.TextureLoader().load('panorama.jpg', texture => {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.x = -1;
                    
                    const geometry = new THREE.SphereGeometry(500, 128, 128);
                    const material = new THREE.MeshBasicMaterial({
                        map: texture,
                        side: THREE.BackSide
                    });
                    
                    const sphere = new THREE.Mesh(geometry, material);
                    scene.add(sphere);
                    
                    pathsData.forEach(pathData => {
                        const points = pathData.points.map(p => new THREE.Vector3(p.x, p.y, p.z));
                        
                        for (let i = 0; i < points.length - 1; i++) {
                            const start = points[i];
                            const end = points[i + 1];
                            
                            const direction = new THREE.Vector3().subVectors(end, start);
                            const distance = direction.length();
                            
                            if (distance < 5) continue;
                            
                            const cylinder = new THREE.Mesh(
                                new THREE.CylinderGeometry(3.5, 3.5, distance, 12),
                                new THREE.MeshStandardMaterial({ 
                                    color: pathData.color,
                                    emissive: pathData.color,
                                    emissiveIntensity: 0.3
                                })
                            );
                            
                            const quaternion = new THREE.Quaternion();
                            quaternion.setFromUnitVectors(
                                new THREE.Vector3(0, 1, 0),
                                direction.clone().normalize()
                            );
                            
                            cylinder.applyQuaternion(quaternion);
                            
                            const center = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                            cylinder.position.copy(center);
                            
                            scene.add(cylinder);
                        }
                    });
                });
                
                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableZoom = true;
                controls.enablePan = false;
                controls.enableDamping = true;
                controls.autoRotate = true;
                controls.autoRotateSpeed = 0.5;
                
                function animate() {
                    requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                }
                animate();
                
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
            });
    </script>
</body>
</html>